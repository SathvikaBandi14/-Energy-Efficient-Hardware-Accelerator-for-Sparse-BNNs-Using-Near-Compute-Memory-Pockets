#include <ap_int.h>
#include <hls_stream.h>
#include "pe_unit.h"
#include "bnn_config.h"

// Include your CSR header files generated by the Python script
#include "conv1_data.h"
#include "conv2_data.h"
#include "fc1_data.h"
#include "fc2_data.h" // Exported as standard weights/bias for final layer
#include "maxpool.h"
#include "line_buffer.h"
#include "binarize.h"
#include "line_buffer_multi.h"
// ============================================================
// CONV1: 28x28 -> 26x26 -> 13x13
// ============================================================
void compute_conv1(
    hls::stream<ap_uint<8>> &in_pixels,
    hls::stream<ap_uint<64>> &out_bits 
) {
    hls::stream<ap_uint<1>> bin_stream("bin1");
    hls::stream<ap_uint<9>> patch_stream("patch1"); 
    hls::stream<ap_uint<64>> raw_out("raw1");
    hls::stream<ap_uint<64>> temp_stream_conv1("temp_stream_conv1");
    // Corrected depths for 28x28 spatial map
    #pragma HLS STREAM variable=bin_stream depth=784
    #pragma HLS STREAM variable=patch_stream depth=784
    #pragma HLS STREAM variable=raw_out depth=784

    binarize(in_pixels, bin_stream);
    
    // You must use a padded line buffer version to keep it 28x28
    line_buffer_bin_3x3(bin_stream, patch_stream);

    // Template update: NUM_PIXELS = 784
    sparse_bnn_layer<64, 9, 396, 784, 10, 10>(
        patch_stream, raw_out, 
        conv1_cols, conv1_row_ptr, conv1_thresholds_int
    );
    #ifndef __SYNTHESIS__
        std::cout << "--- CONV1 Channel Activation Heatmap ---" << std::endl;
        for (int p = 0; p < 784; p++) {
            ap_uint<64> val = raw_out.read(); // Read from producer
            
            // 1. Calculate and Print Heatmap
            int active = 0;
            for(int c = 0; c < 64; c++) if(val[c] == 1) active++;
            if (p % 28 == 0) std::cout << std::endl;
            
            // Mapping density to ASCII
            char shade = (active == 0) ? ' ' : (active < 16) ? '.' : (active < 32) ? '+' : '#';
            std::cout << shade;

            // 2. IMMEDIATELY write to a temporary local stream to pass to MaxPool
            // To do this simply, we can use a local temporary stream
            temp_stream_conv1.write(val); 
        }
        // Now pass temp_stream_conv1 to MaxPool instead of raw_out
        binary_maxpool_2x2<64, 28>(temp_stream_conv1, out_bits);
    #else
        binary_maxpool_2x2<64, 28>(raw_out, out_bits);
    #endif
}

void compute_conv2(
    hls::stream<ap_uint<64>> &in_pixels,
    hls::stream<ap_uint<128>> &out_bits 
) {
    hls::stream<ap_uint<576>> patch_stream("patch2");
    hls::stream<ap_uint<128>> raw_out("raw2");
    
    // FIX: Declare the temporary stream used for the heatmap T-junction
    hls::stream<ap_uint<128>> temp_stream_conv2("temp_stream_conv2");

    #pragma HLS STREAM variable=patch_stream depth=196
    #pragma HLS STREAM variable=raw_out depth=196
    #pragma HLS STREAM variable=temp_stream_conv2 depth=196

    line_buffer_multi<64, 14>(in_pixels, patch_stream);

    sparse_bnn_layer<128, 576, 51264, 196, 10, 10>(
        patch_stream, raw_out, 
        conv2_cols, conv2_row_ptr, conv2_thresholds_int
    );

#ifndef __SYNTHESIS__
    std::cout << "\n--- CONV2 Channel Activation Heatmap (14x14) ---" << std::endl;
    
    for (int p = 0; p < 196; p++) {
        ap_uint<128> val = raw_out.read();
        
        int active = 0;
        for(int c = 0; c < 128; c++) {
            if(val[c] == 1) active++;
        }

        if (p % 14 == 0) std::cout << std::endl;
        
        // Intensity mapping
        if (active == 0) std::cout << " "; 
        else if (active < 16)  std::cout << "."; 
        else if (active < 64)  std::cout << "+";
        else std::cout << "#";

        // Write to the temporary stream that feeds MaxPool
        temp_stream_conv2.write(val);
    }
    std::cout << std::endl;

    binary_maxpool_2x2<128, 14>(temp_stream_conv2, out_bits);
#else
    // Direct connection for synthesis
    binary_maxpool_2x2<128, 14>(raw_out, out_bits);
#endif
}
void compute_fc1(
    hls::stream<ap_uint<6272>> &in_vector, // Flattened 128*7*7
    hls::stream<ap_uint<512>> &out_bits
) {
    // NNZ must match your fc1_csr.h export exactly
    sparse_bnn_layer<512, 6272, 2245376, 1, 10, 10>(
        in_vector,
        out_bits,
        fc1_cols,
        fc1_row_ptr,
        fc1_thresholds_int
    );
}

// ============================================================
// FC2: Final Standard Linear Layer (Real-Valued)
// ============================================================
void compute_fc2(
    hls::stream<ap_uint<512>> &in_vector, 
    hls::stream<ap_uint<10>> &out_digit
) {
    ap_uint<512> input_bits = in_vector.read(); 
    float max_score = -1e6; 
    int winner = 0;

    for (int r = 0; r < 10; r++) {
        #pragma HLS PIPELINE II=1
        float score = fc2_bias[r];

        for (int c = 0; c < 512; c++) {
            #pragma HLS UNROLL factor=16
            
            // Calculate 1D index: row index * row width + column index
            int weight_idx = r * 512 + c;

            // Access bit 'c' of the ap_uint 
            if (input_bits[c] == 1) 
                score += fc2_weights[weight_idx]; // Fixed indexing
            else 
                score -= fc2_weights[weight_idx]; // Fixed indexing
        }

        if (score > max_score) {
            max_score = score;
            winner = r;
        }
    }
    out_digit.write(winner);
}